- [C语言笔记](#c语言笔记)
  - [运算符](#运算符)
    - [优先级](#优先级)
    - [隐式类型转换](#隐式类型转换)
  - [指针](#指针)
    - [指针和数组](#指针和数组)
    - [数组指针和指针数组](#数组指针和指针数组)
      - [指针数组](#指针数组)
      - [数组指针](#数组指针)
    - [参数和指针](#参数和指针)
      - [参数和返回值](#参数和返回值)
      - [形参和实参](#形参和实参)
      - [传值和传址](#传值和传址)
      - [可变参数](#可变参数)
    - [指向指针的指针](#指向指针的指针)
  - [逻辑控制语句](#逻辑控制语句)
    - [switch语句](#switch语句)
  - [数组](#数组)
    - [数组定义和初始化](#数组定义和初始化)
      - [一维数组](#一维数组)
      - [二维数组](#二维数组)
  - [函数](#函数)
  - [字符串](#字符串)
    - [1.字符常量](#1字符常量)
      - [1.1 ASCII](#11-ascii)
      - [1.2 转义字符](#12-转义字符)
      - [1.3   0   '0'   和   '\\0'](#13--0--0--和--0)
    - [2. 字符串常量](#2-字符串常量)
      - [2.1 "xxx" 表示的是字符串首字符的地址](#21-xxx-表示的是字符串首字符的地址)
      - [2.2 为什么char\*存储字符串](#22-为什么char存储字符串)
      - [2.3 计算字符串的长度](#23-计算字符串的长度)
    - [3.字符数组和字符串常量的区别](#3字符数组和字符串常量的区别)
      - [3.1 常量区](#31-常量区)
      - [3.2 字符数组和字符串常量](#32-字符数组和字符串常量)
        - [const](#const)
        - [strlen()源码](#strlen源码)
          - [NULL可以为任意指针赋值](#null可以为任意指针赋值)
        - [Debug 和 Release模式区别](#debug-和-release模式区别)
  - [内存管理](#内存管理)
    - [内存分区](#内存分区)
    - [常量区](#常量区)
      - [特点](#特点)
    - [栈区](#栈区)
      - [特点](#特点-1)
    - [全局区](#全局区)
      - [特点](#特点-2)
    - [静态区](#静态区)
      - [静态局部变量](#静态局部变量)
      - [静态全局变量](#静态全局变量)
    - [堆区](#堆区)
    - [GetMemory的几个笔试题](#getmemory的几个笔试题)
      - [Test1](#test1)
      - [Test2](#test2)
      - [Test3](#test3)
      - [Test4](#test4)
      - [Test5](#test5)
      - [Test6](#test6)
  - [结构体联合枚举](#结构体联合枚举)
    - [结构体](#结构体)
      - [typedef](#typedef)
      - [结构体声明](#结构体声明)
      - [结构体实例化--创建对象](#结构体实例化--创建对象)
      - [结构体内存计算](#结构体内存计算)
        - [有效对齐值](#有效对齐值)
        - [计算规则](#计算规则)
      - [结构体属性访问](#结构体属性访问)
    - [联合体](#联合体)
      - [大端和小端](#大端和小端)
    - [枚举](#枚举)
  - [预处理操作+多文件编程+文件操作](#预处理操作多文件编程文件操作)
    - [预处理](#预处理)
      - [所有预处理器命令都是以`#`开头](#所有预处理器命令都是以开头)
      - [预定义宏](#预定义宏)
      - [宏函数](#宏函数)
      - [预处理器运算符](#预处理器运算符)
        - [宏延续运算符(\\)](#宏延续运算符)
        - [字符串常量化运算符(#)](#字符串常量化运算符)
        - [标记粘贴运算符(##)](#标记粘贴运算符)
    - [多文件编程](#多文件编程)
      - [自定义头文件](#自定义头文件)
    - [文件操作](#文件操作)

# C语言笔记

## 运算符

### 优先级

| 优先级 | 运算符    | 名称或含义    | 使用形式           | 结合方向 | 说明    |
|-----|--------|----------|----------------|------|-------|
| 1   | []     | 数组下标     | 数组名[常量表达式]     | 左到右  | --    |
|     | ()     | 圆括号      | (表达式）/函数名(形参表) |      | --    |
|     | .      | 成员选择（对象） | 对象.成员名         |      | --    |
|     | ->     | 成员选择（指针） | 对象指针->成员名      |      | --    |
|     |        |          |                |      |       |
| 2   | -      | 负号运算符    | -表达式           | 右到左  | 单目运算符 |
|     | ~      | 按位取反运算符  | ~表达式           |      |       |
|     | ++     | 自增运算符    | ++变量名/变量名++    |      |       |
|     | --     | 自减运算符    | --变量名/变量名--    |      |       |
|     | *      | 取值运算符    | *指针变量          |      |       |
|     | &      | 取地址运算符   | &变量名           |      |       |
|     | !      | 逻辑非运算符   | !表达式           |      |       |
|     | (类型)   | 强制类型转换   | (数据类型)表达式      |      | --    |
|     | sizeof | 长度运算符    | sizeof(表达式)    |      | --    |
|     |        |          |                |      |       |
| 3   | /      | 除        | 表达式/表达式        | 左到右  | 双目运算符 |
|     | *      | 乘        | 表达式*表达式        |      |       |
|     | %      | 余数（取模）   | 整型表达式%整型表达式    |      |       |
| 4   | +      | 加        | 表达式+表达式        | 左到右  | 双目运算符 |
|     | -      | 减        | 表达式-表达式        |      |       |
| 5   | <<     | 左移       | 变量<<表达式        | 左到右  | 双目运算符 |
|     | >>     | 右移       | 变量>>表达式        |      |       |
|     |        |          |                |      |       |
| 6   | >      | 大于       | 表达式>表达式        | 左到右  | 双目运算符 |
|     | >=     | 大于等于     | 表达式>=表达式       |      |       |
|     | <      | 小于       | 表达式<表达式        |      |       |
|     | <=     | 小于等于     | 表达式<=表达式       |      |       |
| 7   | ==     | 等于       | 表达式==表达式       | 左到右  | 双目运算符 |
|     | ！=     | 不等于      | 表达式!= 表达式      |      |       |
|     |        |          |                |      |       |
| 8   | &      | 按位与      | 表达式&表达式        | 左到右  | 双目运算符 |
| 9   | ^      | 按位异或     | 表达式^表达式        | 左到右  | 双目运算符 |
| 10  | |      | 按位或      | 表达式|表达式        | 左到右  | 双目运算符 |
| 11  | &&     | 逻辑与      | 表达式&&表达式       | 左到右  | 双目运算符 |
| 12  | ||     | 逻辑或      | 表达式||表达式       | 左到右  | 双目运算符 |
|     |        |          |                |      |       |
| 13  | ?:     | 条件运算符    | 表达式1?          | 右到左  | 三目运算符 |
|     |        |          | 表达式2: 表达式3     |      |       |
|     |        |          |                |      |       |
| 14  | =      | 赋值运算符    | 变量=表达式         | 右到左  | --    |
|     | /=     | 除后赋值     | 变量/=表达式        |      | --    |
|     | *=     | 乘后赋值     | 变量*=表达式        |      | --    |
|     | %=     | 取模后赋值    | 变量%=表达式        |      | --    |
|     | +=     | 加后赋值     | 变量+=表达式        |      | --    |
|     | -=     | 减后赋值     | 变量-=表达式        |      | --    |
|     | <<=    | 左移后赋值    | 变量<<=表达式       |      | --    |
|     | >>=    | 右移后赋值    | 变量>>=表达式       |      | --    |
|     | &=     | 按位与后赋值   | 变量&=表达式        |      | --    |
|     | ^=     | 按位异或后赋值  | 变量^=表达式        |      | --    |
|     | |=     | 按位或后赋值   | 变量|=表达式        |      | --    |
|     |        |          |                |      |       |
| 15  | ，      | 逗号运算符    | 表达式,表达式,…      | 左到右  | --    |

注：除数为0属于运行错误

### 隐式类型转换

若参与运算的数据类型不同，先转换成同一类型：

1. 转换按照数据长度增加的方向进行以保证精度不降低 精度小 -> 精度大。.float : 4字节 short: 8字节
2. 类型不同时， 简单类型向复杂类型转换 char -> short -> int -> float -> double
3. 赋值运算时，赋值号两边数据类型不相同时，将会把右边表达式的数据类型转化成左边表达式的数据类型
4. 在赋值运算当中，赋值号左右两端的类型应当是相互兼容的

## 指针

指针只是存储内存地址的整数

### 指针和数组

​`int a[1000] = {0} //将数组所有元素全部初始化为0`

数组名 == 数组第一个元素的地址  
*数组名不是左值，但是指针是左值*

### 数组指针和指针数组

#### 指针数组

​`int *p1[5];`​ 指针数组是一个数组， 每个数组元素存放一个指针变量

```c
#include <stdio.h>

int main(void) {
    char *p1[5] = {"让编程改变世界 -- 鱼c工作室", "Just do it -- NIKe",
                   "一切皆有可能 -- 李宁", "永不止步 -- 安踏",
                   "One more thing -- 苹果"};
    int i = 0;
    for (i = 0;i < 5;i++ ){
    printf("%s\n", p1[i]);
}
    return 0;
}
```

#### 数组指针

​`int (*p)[5] = &array //跨度为5 * sizeof(int)`​

```c
#include <stdio.h>

int main(void)
{
    char *array[5] = {"FishC", "Five", "Star", "Good", "WoW"};
    char *(*p)[5] = &array;
    int i, j;
    for (i = 0; i < 5; i++)
    {
        for (j = 0; j < 5; j++)
        {
            if ((*p)[j][i] == '\0')
            {
                break;
            }
            printf("%c ", (*p)[j][i]);
        }
        printf("\n");
    }
    return 0;
}
```

### 参数和指针

#### 参数和返回值

类型名 函数名（参数列表）  
{  
&emsp;函数体  
}

#### 形参和实参

```c
#include <stdio.h>

int sum(int, int);

int sum(int x, int y)
{
    return (x + y);//形参仅在函数内部有效
}

int main()
{
    sum(3, 5);

    return 0;
}
```

#### 传值和传址

#### 可变参数

需要使用头文件`#include <stdarg.h>`​

```c
#include <stdarg.h>
#include <stdio.h>

int sum(int n, ...);

int sum(int n, ...)
{
    int i, sum = 0;
    va_list vap;

    va_start(vap, n);
    for (i = 0; i < n; i++)
    {
        sum += va_arg(vap, int);
    }
    va_end(vap);

    return sum;
}

int main(void)
{
    int result = sum(3, 1, 2, 3);
    printf("result = %d\n", result);
    return 0;
}
```

result = 6

### 指向指针的指针

```c
#include <stdio.h>

#define MAX 100

int main(void)
{
    int num = 520;
    int *p = &num;
    int **pp = &p;

    printf("num = %d\n", num);
    printf("*p = %d\n", *p);
    printf("**pp = %d\n", **pp);
    printf("&p : %p, pp :%p\n", &p, pp);

    return 0;
}
```

虽然指针可以无限的指下去， 但是不建议。

## 逻辑控制语句

### switch语句

```c
#include <stdio.h>

int main() {
    int n1, n2;
    char c;
    scanf("%d%c%d", &n1, &c, &n2);
    switch (c)
    {
    case'+':
        printf("%d%c%d=%d\n", n1, c, n2, n1 + n2);
        break;
    case'-':
        printf("%d%c%d=%d\n", n1, c, n2, n1 - n2);
        break;
    case'*':
        printf("%d%c%d=%d\n", n1, c, n2, n1 * n2);
        break;
    case'/': {
        if (n2 == 0) {
            printf("除数不能为0\n");
            break;
        }
        printf("%d%c%d=%d\n", n1, c, n2, n1 / n2);
        break;
    }
    default:
        printf("输入错误\n");
        break;
    }
    return 0;
}
```

任意两个 case 跟随的整型常量值不能相同

## 数组

### 数组定义和初始化

#### 一维数组

`int nums[100] = { 0 };`100个元素全初始化为0  
`int nums[] = {1, 2, 3};`  
`int nums[3] = {1, 2, 3};`  

#### 二维数组

`int nums[2][2];`  
`int nums[][2] = {{1, 2},{3, 4}};` 行可省略  

[指针和数组](#指针和数组)

## 函数

数组作函数参数会退化为指针

## 字符串

### 1.字符常量

> **'a' &emsp; 'b' &emsp; 'c' &emsp; '5'**

#### 1.1 ASCII

ASCII 字符表上的数字 0~31 以及 127（共 33 个）分配给了控制字符，用于控制像打印机等一些外围设备：

|**二进制**|**十进制**|**十六进制**|**缩写**|**含义**|
| -----------| -----| ----| -----| -------------------------------------|
|0000 0000|0|00|NUL|空字符|
|0000 0001|1|01|SOH|标题开始|
|0000 0010|2|02|STX|文本开始|
|0000 0011|3|03|ETX|文本结束|
|0000 0100|4|04|EOT|传输结束|
|0000 0101|5|05|ENQ|请求|
|0000 0110|6|06|ACK|确认响应|
|0000 0111|7|07|BEL|响铃|
|0000 1000|8|08|BS|退格|
|0000 1001|9|09|HT|水平制表符|
|0000 1010|10|0A|LF|换行符|
|0000 1011|11|0B|VT|垂直制表符|
|0000 1100|12|0C|FF|换页符|
|0000 1101|13|0D|CR|回车键|
|0000 1110|14|0E|SO|取消变换（Shift out）|
|0000 1111|15|0F|SI|启动变换（Shift in）|
|0001 0000|16|10|DLE|数据链路转义|
|0001 0001|17|11|DC1|设备控制一（XON 激活软件速度控制）|
|0001 0010|18|12|DC2|设备控制二|
|0001 0011|19|13|DC3|设备控制三（XOFF 停用软件速度控制）|
|0001 0100|20|14|DC4|设备控制四|
|0001 0101|21|15|NAK|拒绝接收|
|0001 0110|22|16|SYN|同步空闲|
|0001 0111|23|17|ETB|区块传输结束|
|0001 1000|24|18|CAN|取消|
|0001 1001|25|19|EM|连接介质中断|
|0001 1010|26|1A|SUB|替换|
|0001 1011|27|1B|ESC|退出键|
|0001 1100|28|1C|FS|文件分区符|
|0001 1101|29|1D|GS|组群分隔符|
|0001 1110|30|1E|RS|记录分隔符|
|0001 1111|31|1F|US|单元分隔符|
||||||
|0111 1111|127|7F|DEL|删除|

字符表上的数字 32~126 分配给了能在键盘上找到的字符，当您查看或打印文档时就会出现：
|**二进制**|**十进制**|**十六进制**|**缩写**|**含义**|
|----------|-----|----|----------------|----|
| 00100000 | 32  | 20 | \(Space\)      | 空格 |
| 00100001 | 33  | 21 | \!             |    |
| 00100010 | 34  | 22 | "              |    |
| 00100011 | 35  | 23 | \#             |    |
| 00100100 | 36  | 24 | $              |    |
| 00100101 | 37  | 25 | %              |    |
| 00100110 | 38  | 26 | &              |    |
| 00100111 | 39  | 27 | '              |    |
| 00101000 | 40  | 28 | \(             |    |
| 00101001 | 41  | 29 | \)             |    |
| 00101010 | 42  | 2A | \*             |    |
| 00101011 | 43  | 2B | \+             |    |
| 00101100 | 44  | 2C | ,              |    |
| 00101101 | 45  | 2D | \-             |    |
| 00101110 | 46  | 2E | \.             |    |
| 00101111 | 47  | 2F | /              |    |
| 00110000 | 48  | 30 | 0              |    |
| 00110001 | 49  | 31 | 1              |    |
| 00110010 | 50  | 32 | 2              |    |
| 00110011 | 51  | 33 | 3              |    |
| 00110100 | 52  | 34 | 4              |    |
| 00110101 | 53  | 35 | 5              |    |
| 00110110 | 54  | 36 | 6              |    |
| 00110111 | 55  | 37 | 7              |    |
| 00111000 | 56  | 38 | 8              |    |
| 00111001 | 57  | 39 | 9              |    |
| 00111010 | 58  | 3A | :              |    |
| 00111011 | 59  | 3B | ;              |    |
| 00111100 | 60  | 3C | <              |    |
| 00111101 | 61  | 3D | =              |    |
| 00111110 | 62  | 3E | >              |    |
| 00111111 | 63  | 3F | ?              |    |
| 01000000 | 64  | 40 | @              |    |
| 01000001 | 65  | 41 | A              |    |
| 01000010 | 66  | 42 | B              |    |
| 01000011 | 67  | 43 | C              |    |
| 01000100 | 68  | 44 | D              |    |
| 01000101 | 69  | 45 | E              |    |
| 01000110 | 70  | 46 | F              |    |
| 01000111 | 71  | 47 | G              |    |
| 01001000 | 72  | 48 | H              |    |
| 01001001 | 73  | 49 | I              |    |
| 01001010 | 74  | 4A | J              |    |
| 01001011 | 75  | 4B | K              |    |
| 01001100 | 76  | 4C | L              |    |
| 01001101 | 77  | 4D | M              |    |
| 01001110 | 78  | 4E | N              |    |
| 01001111 | 79  | 4F | O              |    |
| 01010000 | 80  | 50 | P              |    |
| 01010001 | 81  | 51 | Q              |    |
| 01010010 | 82  | 52 | R              |    |
| 01010011 | 83  | 53 | S              |    |
| 01010100 | 84  | 54 | T              |    |
| 01010101 | 85  | 55 | U              |    |
| 01010110 | 86  | 56 | V              |    |
| 01010111 | 87  | 57 | W              |    |
| 01011000 | 88  | 58 | X              |    |
| 01011001 | 89  | 59 | Y              |    |
| 01011010 | 90  | 5A | Z              |    |
| 01011011 | 91  | 5B | \[             |    |
| 01011100 | 92  | 5C | \\             |    |
| 01011101 | 93  | 5D | \]             |    |
| 01011110 | 94  | 5E | ^              |    |
| 01011111 | 95  | 5F | \_             |    |
| 01100000 | 96  | 60 | \`             |    |
| 01100001 | 97  | 61 | a              |    |
| 01100010 | 98  | 62 | b              |    |
| 01100011 | 99  | 63 | c              |    |
| 01100100 | 100 | 64 | d              |    |
| 01100101 | 101 | 65 | e              |    |
| 01100110 | 102 | 66 | f              |    |
| 01100111 | 103 | 67 | g              |    |
| 01101000 | 104 | 68 | h              |    |
| 01101001 | 105 | 69 | i              |    |
| 01101010 | 106 | 6A | j              |    |
| 01101011 | 107 | 6B | k              |    |
| 01101100 | 108 | 6C | l              |    |
| 01101101 | 109 | 6D | m              |    |
| 01101110 | 110 | 6E | n              |    |
| 01101111 | 111 | 6F | o              |    |
| 01110000 | 112 | 70 | p              |    |
| 01110001 | 113 | 71 | q              |    |
| 01110010 | 114 | 72 | r              |    |
| 01110011 | 115 | 73 | s              |    |
| 01110100 | 116 | 74 | t              |    |
| 01110101 | 117 | 75 | u              |    |
| 01110110 | 118 | 76 | v              |    |
| 01110111 | 119 | 77 | w              |    |
| 01111000 | 120 | 78 | x              |    |
| 01111001 | 121 | 79 | y              |    |
| 01111010 | 122 | 7A | z              |    |
| 01111011 | 123 | 7B | \{             |    |
| 01111100 | 124 | 7C | \|             |    |
| 01111101 | 125 | 7D | \}             |    |
| 01111110 | 126 | 7E | ~              |    |

#### 1.2 转义字符

​`printf("a = %%d", 3);// a = %d`​​

```c
#include <stdio.h>

int main(){
    char c = '\n';
    printf("%c", c);
    c = '\'';
    printf("%c", c);
    c = '\t';
    printf("%c", c);
    c = '\\';
    printf("%c", c);
    c = '\a';
    printf("%c", c);
    return 0;
}
```

#### 1.3 &emsp; 0 &emsp; '0' &emsp; 和 &emsp; '\0'

> '0'    ==    48
>
> '\0'   ==    0   空字符

### 2. 字符串常量

> &quot;abcdef&quot; &emsp; &quot;123456&quot;

#### 2.1 "xxx" 表示的是字符串首字符的地址

#### 2.2 为什么char*存储字符串

```c
#include <stdio.h>

int main() {
    char *p = "abcdef"; // 地址存放到指针变量中
    p++;
    printf("%c", *p); // b
    return 0;
}
```

#### 2.3 计算字符串的长度

```c
#include <stdio.h>
#include <string.h>

int main() {
    char *p = "\\\a\0\n\012a0";
    printf("%d ", sizeof(p));                // 4
    printf("%d ", sizeof("\\\a\0\n\012a0")); // 8
    int n = strlen(p);
    printf("%d ", n); // 2
    p++;
    p++;
    p++;
    n = strlen(p);
    printf("%d ", n); // 4
    return 0;
}
```

### 3.字符数组和字符串常量的区别

#### 3.1 常量区

不可修改

* 整形常量      ​ 10     123      -1234     0
* 浮点常量        1.234            1.111
* 字符常量        ​ 'a'              '8'
* 字符串常量           &quot;abcdef&quot;
* 地址常量              &amp;a      数组名       函数名

#### 3.2 字符数组和字符串常量

```c
#include <stdio.h>
#include <string.h>

int main() {
    char buf[10] = "abcdef";
    char *p = "abcdef";
    (*buf)++;
    (*p)++; // 字符常量不可修改
    return 0;
}
```

##### const

```c
#include <stdio.h>
#include <string.h>

int main() {
    char a = 'a';
    char b = 'b';
    const char *pa = &a; //*pa不可修改
    pa = &b;
    *pa = 'c';
    char const *pb = &a; //*pb不可修改
    pb = &a;
    *pb = 'c';
    char *const pc = &a; // pc不可修改
    pc = &b;
    *pc = 'c';
    const char *const pd = &a; //都不可修改
    pd = &b;
    *pd = 'c';
    return 0;
}
```

* const如果在\*左， 那么指针变量可以修改,\*指针变量不可以修改
* const如果在\*右， 那么指针变量不可以修改，\*指针变量可以修改

##### strlen()源码

```c
size_t strlen(const char *str) {
    const char *eos = str;
    while(*eos++);
    return (end - str - 1);
}
```

> size_t 表示的是 unsigned int

空指针

指针变量的值为NULL(0), 禁止访问空指针

###### NULL可以为任意指针赋值

```c
#include <stdio.h>
#include <string.h>
#include <assert.h>

unsigned int m_strlen(char const *str) {
    // if (str == NULL){
    // return 0;
    //}
    assert(str); // 断言
    unsigned int n = 0;
    while (*str != '\0') {
        str++;
        n++;
    }
    return n;
}

int main() {
    char p[100] = "";
    scanf("%s", p);
    int n = m_strlen(p);
    printf("%d", n);
    return 0;
}
```

##### Debug 和 Release模式区别

1. Release 对程序优化了，执行效率更高

2. Debug针对程序员使用， 可以方便调试

## 内存管理

### 内存分区

* 常量区
* 栈区
* 全局区
* 静态区
* 堆区

### 常量区

* 整形常量
* 浮点常量
* 字符常量
* 字符串常量
* 地址常量：数组名、函数名

#### 特点

> 不可修改

### 栈区

1. 局部变量
2. 函数形参

#### 特点

> 租来的房子，房子到期自动回收
>
> 1. 访问速度快
> 2. 空间少
> 3. 生命周期和作用域从定义的位置开始到“}”结束

### 全局区

全局变量

#### 特点

> 1. 局部大于全局
> 2. 默认初始化0
> 3. 生命周期 程序开始到程序结束
> 4. 作用域 整个项目

在其他文件中使用全局变量

```c
/*a.c*/
extern int g_value;//全局变量的声明

void setValue(int g) {
 g_value = g;
}
```

```c
/*main.c*/
#include <stdio.h>

int g_value = 100;

int main(int argc, char __ argv){
    setValue(200);
    printf("%d\n", g_value);
    return 0;
}
```

### 静态区

#### 静态局部变量

__特点__：​

> 1. 生命周期 程序开始到程序结束
> 2. 作用域     从定义的开始到“}”结束
> 3. 只被初始化一次

#### 静态全局变量

```c
#include <stdio.h>

void getValue(){
    static int s = 10;
    int n = 10;
    printf("%d ", s++);
    printf("%d ", n++);
}

int main(){
    getValue();//10 10
    getValue();//11 10
    return 0;
}
```

__特点：__

> 1. 生命周期         程序开始到程序结束
> 2. 作用域             当前文件

### 堆区

__特点__：​

> 自己买的房子，不会自动释放
>
> 1. 不会自动释放
> 2. 容量大
> 3. 访问速度慢
> 4. 堆区空间没有名字

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(){
    char *p = malloc(500);  // 在堆区分配500个字节的空间 => char p[500];
    p[0] = 'a';
    p[1] = 'c';
    strcpy(p, "abcdef");
    printf("%s", p);
    free(p);//不用时，一定手动释放空间
    return 0;
}
```

> ​`char *p = malloc(500); <==> char p[500];`​

### <u>GetMemory的几个笔试题</u>

Getmemory的几个经典的关于内存的笔试题

输出结果以及出现的错误

#### Test1

```c
void GetMemory1(char* p) {
 p = (char *)malloc(100);
}
void Test1() {
    char* str = NULL;
    GetMemory1(str);
    strcpy(str, "hello world");
    printf(str);
}
```

`p`是值传递，`str`不会被改变

修改方法：

1. 将`GetMemory1()`返回值类型改为char *,返回堆区的地址，并用`str`接收

```c
char* GetMemory1(void) {
    return (char *)malloc(100);
}

void Test1() {
    char *str = NULL;
    str = GetMemory1();
    strcpy(str, "hello world");
    printf(str);
    free(str);
    str = NULL;
}
```

2. 将`GetMemory1()`的参数类型改为二级指针，传入`str`的地址即可

```c
void Test1() {
    char *str = NULL;
    GetMemory1(&str);
    strcpy(str, "hello world");
    printf(str);
    free(str);
    str = NULL;
}
```

#### Test2

```c
char *GetMemory2() {
    char p[] = "hello world"; // p是局部变量
    return p;                 // 试图返回局部变量的地址
}

void Test2() {
    char *str = NULL;
    str = GetMemory2();
    printf(str);
}
```

`p`中存放的是栈区的地址，函数结束后栈区数据被释放
修改方法：Test3 or Test4

#### Test3

```c
char *GetMemory3() {
    char *p = "hello world"; // p是局部变量
    return p;                // 返回常量的地址
}

void Test3() {
    char *str = NULL;
    str = GetMemory3();
    printf(str);
}
```

输出："hello world"

#### Test4

```c
char *GetMemory4() {
    static char p[] = "hello world";
    return p;
}

void Test4() {
    char *str = NULL;
    str = GetMemory4();
    printf(str);
}
```

输出："hello world"

#### Test5

```c
void Test5() {
    char *str = (char *)malloc(100);
    strcpy(str, "hello");
    free(str); // 堆存放的数据释放
    // str = NULL //为了防止访问非法的空间，释放后，指向NULL
    if (str != NULL) {
        strcpy(str, "wold");
        printf(str);
    }
}
```

堆空间已经释放，访问非法
修改方法：

1. 将`free()`移动到程序末尾

#### Test6

```c
void Test6() {
    char *str = (char *)malloc(100);
    strcpy(str, "hello");
    str += 6;
    free(str); // str已经被修改 无法正常释放
    // str = NULL
    if (str != NULL) {
        strcpy(str, "wold");
        printf(str);
    }
}
```

释放时地址应和申请时的地址一致
修改方法：

1. 删除`str += 6;`，并将`free()`移动到程序末尾

## 结构体联合枚举

### 结构体

#### typedef

使用typedef可以为类型取一个新的名字  
例如

```c
typedef unsigned char BYTE;//为单字节数字定义一个类型BYTE
```

#### 结构体声明

```c
struct people{
    int age;
    char name;
    int age;
    char sex;
};
```

#### 结构体实例化--创建对象

```c
struct people{
    int age;
    char name;
    int age;
    char sex;
}p;
```

#### 结构体内存计算

##### 有效对齐值

对齐系数：由编译器决定(vs中默认为0)，也可通过`#pragma pack(n)//n为对齐系数`指定  
**有效对齐值** = min(对齐系数,结构体中最长的数据类型的长度)

##### 计算规则

1. 数据成员：第一个数据成员放在offset为0
的地方，以后的每一个成员的offset都必须是该成员的大小与有效对齐值相比较小的的数值的整数倍。
2. 结构体作为成员：如果一个结构体里有某些结构体成员，则结构体要从其内部有效对齐值的整数倍地址开始存储
3. 结构体的总大小，必须是其有效对齐值的整数倍，不足的要补齐。

#### 结构体属性访问

1. 结构体名.属性名  
2. 结构体指针->属性名

```c
#include <stdio.h>

typedef struct Student
{
 int num;//序号
 char name;//姓名
 float score[3];
 double aver;
}Student;

int main() {
 Student student[3] = { {0, "zx", {90,87,60}},{1,"zv"} };
 Student* p = student;
 printf("%d\n", (p+1) ->num);
 printf("%d\n", (*(p + 1)).num);
 printf("%d\n", p[1].num);
 return 0;
}
```

### 联合体

共用体也称联合，是一种特殊的数据类型，允许在相同的内存位置存储不同的数据类型。可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。  
所占内存由需要内存最大的变量决定

```c
#include <stdio.h>
typedef union Student{
    int a;
    char c;
}un;

int main(){
    un u;
    u.c = 1;
    printf("%d ", sizeof(un));
    printf("%d ", u.a);
    return 0;
}
```

#### 大端和小端

1. 小端：低位放在低地址 高位放在高地址
2. 大端：低位放在高地址 高位放在低地址

### 枚举

```c
enum WEEKS {
    SUN,
    MON,
    TUE,
    WED,
    THU,
    FRI,
    SAT
};
enum WEEKS day;
```

第一个枚举成员的默认值为**整型**的0，后续枚举成员的前一个上加1。*可以省略枚举名，直接命名枚举变量*

## 预处理操作+多文件编程+文件操作

### 预处理

#### 所有预处理器命令都是以`#`开头  

`#include`包含头文件  
`#undef`取消宏定义  
`#define`宏定义  
`#ifndef`如果未定义

#### 预定义宏

`__DATE__`等

#### 宏函数

无返回值
参数无类型

```c
#define MAX(a, b)        \
    if (a > b) {         \
        printf("%d", a); \
    } else {             \
        printf("%d", b); \
    }
```

#### 预处理器运算符

##### 宏延续运算符(\\)

&emsp;&emsp;一个宏通常写在一个单行上。如果宏太长，一个单行容纳不下，则使用宏延续运算符(\\)。

##### 字符串常量化运算符(#)

&emsp;&emsp;在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符(#)。在宏中使用的该运算符有一个特定的参数或参数列表，例如

```c
#include <stdio.h>

#define debug(x, y) printf("%s 的值是 %d \n", #x, y);

int main() {
    int num = 10;
    debug(num, num);
    return 0;
}
```

##### 标记粘贴运算符(##)

宏定义内的标记粘贴运算符(##)会合并两个参数，它允许在宏定义中两个独立的标记被合并为一个标记。例如

```c
#include <stdio.h>

#define TYPE1(type, name) type name_##type##_type
#define TYPE2(type, name) type name##_##type##_type
int main() {
    TYPE1(int, c); //int name_int_type
    name_int_type = 10;
    printf("%d ", name_int_type);
    TYPE2(int, d); //int d_int_type
    d_int_type = 20;
    printf("%d ",d_int_type);
    return 0;
}

```

### 多文件编程

`<>`从标准库中查找头文件  
`""`优先从工作目录查找  

#### 自定义头文件

```c
#pragma once
//避免头文件被重复包含

//1.包含头文件
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

//2.函数声明
char*m_strcpy(char *s, const char* t);

//3.结构体定义
typedef struct peo{
    int num;
    char name[20];
}p;

//4.联合体定义
union nu{
    int a;
    char c;
};

//5.枚举定义
enum {
    a,
    b = 5
};

//6.宏定义
#define NUM 10

//7.全局变量声明
extern int n;//不给值
```

### 文件操作

```c
#include <stdio.h>
#include <string.h>

int main(){
    //1.打开文件
    FILE* fr = fopen("test.txt","r");
    FILE* fw = fopen("notExist.txt","w");
    if(fr == NULL || fw == NULL){
        printf("文件不存在\n");
        return 0;
    }
    //2.读写文件
    char buf[128] = "";//过渡容器
    while(fgets(buf, 128, fr) != NULL){
        fputs(buf,fw);
    //3.关闭文件
    fclose(fr);
    fclose(fw);

}
```
